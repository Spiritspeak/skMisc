% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/skUtils.R
\name{lazylogic}
\alias{lazylogic}
\alias{lazy_any}
\alias{lazy_all}
\title{Logical operators using lazy evaluation}
\usage{
lazy_any(...)

lazy_all(...)
}
\arguments{
\item{...}{Expressions evaluating to single logical values.}
}
\value{
A logical value.
}
\description{
These functions sequentially evaluate their arguments and return
a logical value when sufficient information has been acquired to do so. 
Hence, \code{lazy_any()} will not evaluate any arguments 
beyond the first \code{TRUE}, since there is already
at least one \code{TRUE} value, so \code{TRUE} can be returned.
Likewise, \code{lazy_all()} will not evaluate beyond the first \code{FALSE} 
it is already clear not all arguments are \code{TRUE}, 
so \code{FALSE} is returned. 

This enables logical chains in which you can use logical statements 
earlier in the chain to check whether logical statements 
further down the chain can be evaluated or would cause errors. 
If a checking statement evaluates to the terminating condition 
of the used function, 
further arguments are not evaluated and hence no error is triggered.
}
\examples{
# The final argument is not evaluated because 
# the function reaches its termination condition 
# (TRUE) before that.
lazy_any(FALSE, TRUE, stop())

# Dealing with problematic NULL, NA, and multi-value inputs
myvecs <- list(a=NULL,b=NA,c=c(1,5,2),d=10)
outcomes <- logical(length(myvecs))
for(i in seq_along(myvecs)){
  outcomes[i] <- lazy_all(!is.null(myvecs[[i]]),
                          !length(myvecs[[i]]) != 1,
                          !is.na(myvecs[[i]]),
                          myvecs[[i]] == 10)
}

}
